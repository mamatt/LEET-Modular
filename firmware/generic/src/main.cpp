//-----10|-------20|-------30|-------40|-------50|-------60|-------70|-------80|

// ***********************************************************************************
// LEET modular - a versatile, easy to build, affordable and powerful eurorack module!
// ***********************************************************************************

// todo:
// * integrate midi to cv code
// * clean up code 
// * implement s&h
// * implement vca, attenuverter etc
// * transparent image for dual color intro
// * rainbow intro?
// * why is one ouput affecting the other in calibration manual cv? (variations in AD or vcc -> pots?)
// * move generated contents (python scripts) to external files (with .h)
// * improve potentiometer calibration
// * design and print dual attenuated output (with improved clip)

// done:
// * implement vcf and a few different filters
// * implement primitive delay
// * add dead zone for pot controling ammount of modulation
// * add logo for playback
// * invert tempo for playback
// * fix levels for am (enabling folding)
// * color code cv and pot levels
// * fix voltage levels for osc, adsr etc (not 20VPP)
// * implement adsr
// * add boot image
// * improve vco implementation (new menu with am,fm etc)
// * change AD range (amplification to allow 16 steps between each note (10V @1920 instead of 2048))
// * replace qLut with function (divide AD to get index)
// * switch to float xStep? (incl LUTs)
// * add quantization for cv-in
// * add pulsewidth for squarewave
// * add icons to modes
// * clean up code in modules
// * implement tft menu system with encoder interrupt
// * implement potentiometer filtering (running average)
// * replace waveform with 16 bit position (0-65534)
// * implement reliable rotation encoder support
// * implement ADC DMA reading
// * implement tmrIRQ for playback @ 44.1kHz
// * update spi and display to support 240x240 tft with st7789 driver
// * verify ADC resolution
// * optimize display update (remove flickering)

// note: calibration values for unconnected input (potentiometer calibration): 3238 // target 2473

// #define pcb_version 0 // the first 3dpcb version
#define pcb_version 1 // the first pcb version, marked rev 1 (menu and P2,P3 direction changed)

#include <stdio.h>
extern "C"
{
#include "drivers/SysTick.h"
#include "drivers/led.h"
#include "drivers/display.h"
#include "drivers/spi.h"
#include "drivers/timer.h"
#include "drivers/encoder.h"
#include "drivers/adc.h"
#include "drivers/scope.h"
#include "module_vco.h"
#include "module_noise.h"
#include "module_vcf.h"
#include "module_adsr.h"
#include "module_delay.h"
#include "gd32vf103.h"
  extern "C" const uint8_t font[1520];
  extern "C" const float freq[2113];
}

timer T;
led LED;
SysTick stk;
display Display;
spi SPI;
encoder enc;
adc ADC;
module_vco vco;
module_noise noise;
module_vcf vcf;
module_adsr adsr;
module_delay delay;
scope ch0(RGBToWord(0xff, 0x00, 0xff));
scope ch1(RGBToWord(0x00, 0xff, 0xff));
scope ch0old(RGBToWord(0x00, 0x00, 0x00));
scope ch1old(RGBToWord(0x00, 0x00, 0x00));

// menu structure generated by python script:
const char *menuTxt[] = {"OSC", "< back", "sine am", "sine add", "sine fm", "square am", "square add", "square fm", "square pw", "square 2x", "square 3x", "triangle am", "triangle add", "triangle fm", "triangle saw", "triangle 2x", "triangle 3x", "quantize", "cvout", "Noise", "LFO", "< back", "LFO sine", "LFO square", "LFO triangle", "VCF", "< back", "2 pole v1", "2 pole v2", "4 pole", "test", "VCA", "SnH", "Envelope", "<back", "ADSR", "ADR", "Delay", "CV_Play", "Settings", "< back", "calibrate", "< back", "help", "out minus10", "out 0V", "out 3V3", "out 10V", "in1 to out1", "in2 to out1", "pass thru", "square A4", "manual sine", "manual CV", "about", "< back", "Modular 1337", "Version 0.85", "Not Implemented", "< back", "Mixer", "Sequencer", "Sampler"};
uint8_t menuPre[] = {0, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 0, 19, 21, 21, 22, 23, 20, 26, 26, 27, 28, 29, 25, 31, 32, 34, 34, 35, 33, 37, 38, 40, 40, 42, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 41, 55, 55, 56, 39, 59, 59, 60, 61};
uint8_t menuNxt[] = {19, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 18, 20, 25, 22, 23, 24, 24, 31, 27, 28, 29, 30, 30, 32, 33, 37, 35, 36, 36, 38, 39, 58, 41, 54, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 53, 54, 56, 57, 57, 58, 60, 61, 62, 62};
uint8_t menuSel[] = {2, 0, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 22, 20, 146, 147, 148, 27, 25, 150, 151, 152, 153, 160, 161, 35, 33, 162, 163, 164, 165, 41, 39, 43, 41, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 56, 54, 56, 57, 60, 58, 60, 61, 62};
#define mode_sine_am 128
#define mode_sine_add 129
#define mode_sine_fm 130
#define mode_square_am 131
#define mode_square_add 132
#define mode_square_fm 133
#define mode_square_pw 134
#define mode_square_2x 135
#define mode_square_3x 136
#define mode_triangle_am 137
#define mode_triangle_add 138
#define mode_triangle_fm 139
#define mode_triangle_saw 140
#define mode_triangle_2x 141
#define mode_triangle_3x 142
#define mode_quantize 143
#define mode_cvout 144
#define mode_Noise 145
#define mode_LFO_sine 146
#define mode_LFO_square 147
#define mode_LFO_triangle 148
#define mode_2_pole_v1 150
#define mode_2_pole_v2 151
#define mode_4_pole 152
#define mode_test 153
#define mode_VCA 160
#define mode_SnH 161
#define mode_ADSR 162
#define mode_ADR 163
#define mode_Delay 164
#define mode_CV_Play 165
#define mode_help 200
#define mode_out_minus10 201
#define mode_out_0V 202
#define mode_out_3V3 203
#define mode_out_10V 204
#define mode_in1_to_out1 205
#define mode_in2_to_out1 206
#define mode_pass_thru 207
#define mode_square_A4 208
#define mode_manual_sine 209
#define mode_manual_CV 210

// hard coded song CV levels for debug purposes
const uint16_t song[] = {2458, 2526, 2577, 2662, 2731, 2577, 2662, 2731,
                         2458, 2526, 2577, 2662, 2731, 2577, 2662, 2731,
                         2458, 2492, 2611, 2697, 2748, 2611, 2697, 2748,
                         2458, 2492, 2611, 2697, 2748, 2611, 2697, 2748,
                         2441, 2492, 2577, 2697, 2748, 2577, 2697, 2748,
                         2441, 2492, 2577, 2697, 2748, 2577, 2697, 2748};

// compressed images generated with python script
const uint8_t img_vco[212] = {255, 255, 255, 255, 255, 255, 255, 255, 132, 4, 48, 10, 10, 59, 15, 59, 25, 1, 52, 0, 19, 1, 59, 0, 12, 1, 59, 0, 23, 0, 74, 0, 62, 0, 10, 0, 62, 0, 21, 0, 66, 0, 6, 0, 64, 0, 8, 0, 64, 0, 19, 0, 55, 0, 17, 0, 66, 0, 6, 0, 66, 0, 255, 2, 0, 67, 0, 5, 0, 68, 0, 4, 0, 68, 0, 73, 0, 255, 234, 0, 226, 0, 255, 14, 59, 15, 48, 82, 0, 10, 0, 255, 255, 195, 0, 10, 0, 255, 255, 195, 0, 10, 0, 255, 255, 195, 0, 10, 0, 255, 255, 195, 0, 10, 0, 255, 255, 195, 0, 10, 0, 255, 222, 0, 226, 0, 255, 185, 37, 10, 0, 25, 59, 15, 48, 255, 255, 56, 0, 179, 0, 74, 0, 74, 0, 144, 0, 86, 0, 74, 0, 17, 0, 74, 0, 74, 0, 142, 0, 86, 0, 74, 0, 19, 0, 52, 0, 20, 0, 64, 0, 8, 0, 64, 0, 21, 0, 50, 0, 22, 0, 62, 0, 10, 0, 62, 0, 23, 1, 46, 1, 24, 1, 58, 1, 12, 1, 57, 2, 26, 46, 28, 58, 16, 57, 255, 255, 255, 255, 255, 255, 166};
const uint8_t img_lfo[134] = {255, 255, 255, 255, 255, 255, 255, 255, 126, 10, 64, 65, 15, 59, 163, 0, 12, 1, 59, 0, 163, 0, 10, 0, 62, 0, 163, 0, 8, 0, 64, 0, 163, 0, 6, 0, 66, 0, 255, 148, 0, 4, 0, 68, 0, 255, 255, 255, 255, 43, 59, 15, 48, 255, 255, 255, 255, 54, 59, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 29, 59, 255, 255, 255, 255, 43, 59, 91, 48, 255, 255, 237, 0, 150, 0, 156, 0, 150, 0, 17, 0, 150, 0, 154, 0, 150, 0, 19, 0, 64, 0, 84, 0, 64, 0, 21, 0, 62, 0, 86, 0, 62, 0, 23, 1, 57, 2, 88, 1, 57, 2, 26, 57, 11, 10, 70, 57, 255, 255, 255, 255, 255, 255, 166};
const uint8_t img_vcf[184] = {255, 255, 255, 255, 255, 255, 255, 255, 132, 4, 48, 10, 10, 59, 9, 65, 25, 1, 52, 0, 19, 1, 59, 0, 74, 0, 23, 0, 74, 0, 62, 0, 74, 0, 21, 0, 66, 0, 6, 0, 64, 0, 74, 0, 19, 0, 55, 0, 17, 0, 66, 0, 74, 0, 255, 2, 0, 67, 0, 5, 0, 68, 0, 74, 0, 73, 0, 255, 234, 0, 226, 0, 255, 14, 59, 15, 59, 71, 0, 10, 0, 255, 255, 195, 0, 10, 0, 255, 80, 59, 255, 54, 0, 10, 0, 255, 255, 195, 0, 10, 0, 255, 255, 195, 0, 10, 0, 255, 255, 195, 0, 10, 0, 99, 59, 255, 62, 0, 226, 0, 255, 185, 37, 10, 0, 25, 59, 255, 255, 121, 0, 179, 0, 74, 0, 220, 0, 86, 0, 93, 0, 74, 0, 218, 0, 86, 0, 95, 0, 52, 0, 20, 0, 64, 0, 97, 0, 50, 0, 22, 0, 62, 0, 99, 1, 46, 1, 24, 1, 58, 1, 102, 46, 28, 58, 10, 10, 255, 255, 255, 255, 255, 255, 219};
const uint8_t img_vca[216] = {255, 255, 255, 255, 255, 255, 255, 255, 132, 4, 48, 10, 10, 59, 15, 59, 25, 1, 52, 0, 19, 1, 59, 0, 12, 1, 59, 0, 23, 0, 74, 0, 62, 0, 10, 0, 62, 0, 21, 0, 66, 0, 6, 0, 64, 0, 8, 0, 64, 0, 19, 0, 55, 0, 17, 0, 66, 0, 6, 0, 66, 0, 255, 2, 0, 67, 0, 5, 0, 68, 0, 4, 0, 68, 0, 73, 0, 255, 234, 0, 226, 0, 255, 14, 59, 15, 48, 82, 0, 10, 0, 255, 255, 195, 0, 10, 0, 255, 80, 48, 255, 65, 0, 10, 0, 255, 255, 195, 0, 10, 0, 255, 255, 195, 0, 10, 0, 255, 255, 195, 0, 10, 0, 99, 48, 255, 73, 0, 226, 0, 255, 185, 37, 10, 0, 25, 59, 255, 255, 121, 0, 179, 0, 74, 0, 74, 0, 144, 0, 86, 0, 74, 0, 17, 0, 74, 0, 218, 0, 86, 0, 6, 0, 66, 0, 19, 0, 52, 0, 20, 0, 64, 0, 8, 0, 64, 0, 21, 0, 50, 0, 22, 0, 62, 0, 10, 0, 62, 0, 23, 1, 46, 1, 24, 1, 58, 1, 12, 2, 56, 2, 26, 46, 28, 58, 17, 3, 48, 3, 255, 255, 255, 255, 255, 255, 166};
// const uint8_t img_env[196] = {255, 255, 255, 255, 255, 255, 255, 255, 126, 65, 15, 59, 15, 4, 48, 10, 82, 0, 12, 1, 59, 0, 12, 1, 52, 0, 94, 0, 10, 0, 62, 0, 10, 0, 151, 0, 8, 0, 64, 0, 8, 0, 66, 0, 85, 0, 6, 0, 66, 0, 6, 0, 55, 0, 255, 83, 0, 4, 0, 68, 0, 4, 0, 67, 0, 226, 0, 255, 234, 0, 226, 0, 41, 59, 15, 48, 255, 55, 0, 10, 0, 255, 255, 195, 0, 10, 0, 31, 59, 255, 255, 103, 0, 10, 0, 255, 255, 195, 0, 10, 0, 255, 255, 195, 0, 10, 0, 255, 255, 4, 59, 130, 0, 10, 0, 255, 222, 0, 226, 0, 255, 33, 59, 91, 37, 10, 0, 255, 255, 207, 0, 103, 0, 74, 0, 156, 0, 74, 0, 62, 0, 105, 0, 74, 0, 154, 0, 74, 0, 62, 0, 97, 0, 8, 0, 64, 0, 8, 0, 52, 0, 97, 0, 10, 1, 61, 0, 10, 0, 50, 0, 96, 1, 13, 1, 56, 2, 12, 1, 46, 1, 32, 64, 17, 3, 48, 3, 17, 46, 255, 255, 255, 255, 255, 255, 177};
const uint8_t img_dly[139] = {255, 255, 255, 255, 255, 255, 255, 255, 126, 65, 9, 10, 70, 4, 48, 4, 88, 0, 88, 1, 58, 1, 87, 1, 85, 0, 62, 0, 173, 0, 64, 0, 87, 0, 82, 0, 66, 0, 87, 0, 255, 65, 0, 68, 0, 255, 255, 255, 222, 48, 255, 255, 255, 255, 255, 27, 48, 255, 255, 255, 134, 0, 255, 53, 0, 169, 0, 255, 51, 0, 171, 0, 64, 0, 173, 0, 62, 0, 175, 1, 57, 2, 178, 23, 10, 22, 255, 255, 255, 229, 48, 26, 59, 255, 255, 255, 123, 0, 232, 0, 74, 0, 169, 0, 230, 0, 74, 0, 161, 0, 8, 0, 64, 0, 161, 0, 10, 0, 62, 0, 160, 1, 12, 1, 57, 2, 96, 64, 16, 57, 41, 10, 255, 255, 255, 255, 255, 255, 189};
const uint8_t img_snh[182] = {255, 255, 255, 255, 255, 255, 255, 255, 132, 59, 15, 21, 25, 10, 48, 10, 42, 1, 59, 0, 12, 1, 20, 0, 138, 0, 62, 0, 10, 0, 161, 0, 64, 0, 8, 0, 22, 0, 137, 0, 66, 0, 6, 0, 255, 7, 0, 137, 0, 68, 0, 4, 0, 255, 7, 0, 244, 10, 221, 0, 255, 135, 59, 15, 11, 255, 255, 255, 255, 91, 54, 20, 18, 10, 7, 15, 48, 115, 0, 239, 0, 239, 0, 170, 0, 67, 0, 255, 155, 0, 67, 0, 255, 155, 0, 239, 0, 239, 1, 239, 53, 26, 18, 10, 7, 15, 48, 255, 255, 255, 244, 59, 26, 18, 255, 255, 255, 88, 0, 74, 0, 232, 0, 58, 0, 68, 0, 39, 0, 74, 0, 230, 0, 60, 0, 66, 0, 41, 0, 64, 0, 8, 0, 52, 0, 64, 0, 43, 0, 62, 0, 10, 0, 52, 0, 62, 0, 45, 1, 57, 2, 12, 1, 51, 2, 56, 2, 48, 57, 17, 34, 19, 3, 48, 3, 255, 255, 255, 255, 255, 255, 188};
const uint8_t img_play[110] = {255, 255, 255, 255, 255, 255, 255, 255, 136, 3, 234, 0, 3, 0, 232, 0, 5, 0, 239, 0, 239, 0, 239, 0, 239, 0, 239, 0, 239, 0, 239, 0, 239, 0, 239, 0, 239, 0, 239, 0, 239, 0, 239, 0, 239, 0, 239, 0, 239, 0, 239, 0, 239, 0, 255, 255, 208, 0, 237, 0, 237, 0, 237, 0, 237, 0, 237, 0, 237, 0, 237, 0, 237, 0, 237, 0, 237, 0, 237, 0, 237, 0, 237, 0, 237, 0, 237, 0, 237, 0, 237, 0, 230, 0, 5, 0, 232, 0, 3, 0, 234, 3, 255, 255, 255, 255, 255, 255, 255, 113};
const uint8_t img_cal[166] = {255, 255, 255, 255, 255, 255, 255, 255, 132, 59, 15, 59, 9, 10, 80, 1, 59, 0, 12, 1, 59, 0, 99, 0, 62, 0, 10, 0, 62, 0, 97, 0, 64, 0, 8, 0, 64, 0, 95, 0, 66, 0, 6, 0, 66, 0, 255, 78, 0, 68, 0, 4, 0, 68, 0, 255, 255, 255, 255, 43, 59, 15, 48, 255, 255, 255, 255, 130, 48, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 40, 48, 255, 255, 255, 255, 54, 59, 91, 59, 255, 255, 226, 0, 74, 0, 74, 0, 156, 0, 74, 0, 74, 0, 17, 0, 150, 0, 154, 0, 6, 0, 66, 0, 74, 0, 19, 0, 64, 0, 8, 0, 64, 0, 8, 0, 64, 0, 21, 0, 62, 0, 10, 0, 62, 0, 10, 0, 62, 0, 23, 1, 58, 1, 12, 2, 56, 2, 12, 1, 57, 2, 26, 58, 17, 3, 48, 3, 17, 57, 255, 255, 255, 255, 255, 255, 166};
const uint8_t img_1337[465] = {24, 9, 25, 9, 7, 9, 7, 9, 7, 9, 7, 9, 7, 9, 7, 9, 7, 9, 7, 9, 255, 32, 1, 9, 1, 21, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 255, 255, 255, 255, 255, 255, 255, 255, 165, 1, 9, 1, 21, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 255, 32, 9, 25, 9, 7, 9, 7, 9, 7, 9, 7, 9, 7, 9, 7, 9, 7, 9, 7, 9, 255, 255, 255, 4, 9, 61, 9, 7, 9, 7, 9, 43, 9, 255, 50, 1, 9, 1, 57, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 39, 1, 9, 1, 255, 255, 255, 255, 255, 255, 255, 255, 183, 1, 9, 1, 57, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 39, 1, 9, 1, 255, 50, 9, 61, 9, 7, 9, 7, 9, 43, 9, 255, 255, 255, 22, 9, 43, 9, 7, 9, 7, 9, 7, 9, 7, 9, 25, 9, 255, 50, 1, 9, 1, 39, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 21, 1, 9, 1, 255, 255, 255, 255, 255, 255, 255, 255, 183, 1, 9, 1, 39, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 21, 1, 9, 1, 255, 50, 9, 43, 9, 7, 9, 7, 9, 7, 9, 7, 9, 25, 9, 255, 255, 255, 22, 9, 61, 9, 7, 9, 61, 9, 255, 50, 1, 9, 1, 57, 1, 9, 1, 3, 1, 9, 1, 57, 1, 9, 1, 255, 255, 255, 255, 255, 255, 255, 255, 183, 1, 9, 1, 57, 1, 9, 1, 3, 1, 9, 1, 57, 1, 9, 1, 255, 50, 9, 61, 9, 7, 9, 61, 9, 255, 255, 255, 22, 9, 7, 9, 7, 9, 7, 9, 7, 9, 7, 9, 7, 9, 7, 9, 25, 9, 255, 50, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 21, 1, 9, 1, 255, 255, 255, 255, 255, 255, 255, 255, 183, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 3, 1, 9, 1, 21, 1, 9, 1, 255, 25};
const uint8_t img_modular[105] = {22, 7, 10, 6, 255, 255, 255, 255, 161, 2, 3, 3, 57, 6, 35, 10, 255, 255, 255, 74, 3, 21, 14, 38, 7, 6, 7, 30, 14, 9, 18, 170, 3, 255, 255, 255, 78, 2, 3, 3, 13, 3, 3, 6, 3, 3, 9, 10, 67, 10, 3, 3, 13, 6, 3, 3, 255, 255, 255, 70, 7, 67, 10, 94, 3, 46, 3, 118, 7, 255, 255, 255, 142, 3, 3, 6, 255, 255, 255, 79, 6, 13, 3, 32, 6, 13, 3, 6, 3, 13, 6, 116, 3, 14, 3, 12, 7, 13, 3, 45, 3, 255, 255, 255, 26};

// global variables to communicate between tmrINT and main loop
uint8_t moduleMode = mode_sine_am; // function of module selected by menu (fixed menu positions > 127))
// uint8_t moduleMode = mode_triangle_saw; // function of module selected by menu (fixed menu positions > 127))
// uint8_t moduleMode = mode_ADSR; // function of module selected by menu (fixed menu positions > 127))
// uint8_t moduleMode = mode_4_pole; // function of module selected by menu (fixed menu positions > 127))
// uint8_t moduleMode = mode_Delay; // function of module selected by menu (fixed menu positions > 127))

volatile int dispPos = 0; // counter for scope column (update screen when dispPos == 240)
uint8_t menuPos = 0;      // current menu position (< 127)
uint8_t menuUpd = 1;      // signals if menu was updated (=>redraw display)
float phaseC = 0;         // phaseCount | stepsize within one period (0-65535). frequenzy = xStep * 44100 / (2*65536)
uint8_t quantized = 0;    // quantize CV input of module?
uint8_t cvOut = 0;        // use dac0 as cv for vco?
uint8_t scopeTrig = 0;    // flag to init scope sampling

//-----10|-------20|-------30|-------40|-------50|-------60|-------70|-------80|

void rcu_config(void)
{
  rcu_periph_clock_enable(RCU_AF); // GPIO IRQ
  rcu_periph_clock_enable(RCU_GPIOA);
  rcu_periph_clock_enable(RCU_ADC0);
  rcu_periph_clock_enable(RCU_DAC);
  rcu_periph_clock_enable(RCU_DMA0);
  rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV8); // ADC clock = 108MHz / 8 = 13.5MHz(14MHz max.)
}

void gpio_config(void)
{
  gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_0);     // ADC ch0
  gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_3);     // ADC ch1
  gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_6);     // ADC pot UR
  gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_7);     // ADC pot LR
  gpio_init(GPIOB, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_0);     // ADC pot LL
  gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_4);     // DAC ch0
  gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_5);     // DAC ch1
  gpio_init(GPIOB, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_5);     // rotary enc A
  gpio_init(GPIOB, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_6);     // rotary enc B
  gpio_init(GPIOB, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_4);     // rotary enc C
  gpio_init(GPIOC, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_13); // red LED
  gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_1);  // green LED
  gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_2);  // blue LED
}

void dma_config(void)
{
  /* ADC_DMA_channel configuration */
  dma_parameter_struct dma_data_parameter;
  /* ADC DMA_channel configuration */
  dma_deinit(DMA0, DMA_CH0);
  /* initialize DMA single data mode */
  dma_data_parameter.periph_addr = (uint32_t)(&ADC_RDATA(ADC0));
  dma_data_parameter.periph_inc = DMA_PERIPH_INCREASE_DISABLE;
  dma_data_parameter.memory_addr = (uint32_t)(&ADC.anRaw);
  dma_data_parameter.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
  dma_data_parameter.periph_width = DMA_PERIPHERAL_WIDTH_16BIT;
  dma_data_parameter.memory_width = DMA_MEMORY_WIDTH_16BIT;
  dma_data_parameter.direction = DMA_PERIPHERAL_TO_MEMORY;
  dma_data_parameter.number = 5;
  dma_data_parameter.priority = DMA_PRIORITY_HIGH;
  dma_init(DMA0, DMA_CH0, &dma_data_parameter);
  dma_circulation_enable(DMA0, DMA_CH0);
  /* enable DMA channel */
  dma_channel_enable(DMA0, DMA_CH0);
}

void initADC()
{
  /* reset ADC */
  adc_deinit(ADC0);
  /* ADC mode config */
  adc_mode_config(ADC_MODE_FREE); // ADC0 and ADC1 work independently
  /* ADC data alignment config */
  adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);
  /* Configure word length */
  adc_resolution_config(ADC0, ADC_RESOLUTION_12B);
  /* ADC channel length config */
  adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, 5);
  adc_regular_channel_config(ADC0, 0, ADC_CHANNEL_0, ADC_SAMPLETIME_13POINT5); // ADC left 41.4+12.5=54 cycles =5uS *5=20us => 50.1Hz
  adc_regular_channel_config(ADC0, 1, ADC_CHANNEL_3, ADC_SAMPLETIME_13POINT5); // ADC right
  adc_regular_channel_config(ADC0, 2, ADC_CHANNEL_6, ADC_SAMPLETIME_13POINT5); // pot0 (UR)
  adc_regular_channel_config(ADC0, 3, ADC_CHANNEL_7, ADC_SAMPLETIME_13POINT5); // pot1 (LR)
  adc_regular_channel_config(ADC0, 4, ADC_CHANNEL_8, ADC_SAMPLETIME_13POINT5); // pot2 (LL)
  /* ADC trigger config */
  adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_EXTTRIG_REGULAR_NONE); // software trigger
  /* ADC external trigger enable */
  adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);
  /* ADC discontinuous mode */
  adc_discontinuous_mode_config(ADC0, ADC_REGULAR_CHANNEL, 5); // should it be 4?
  /* enable ADC interface */
  adc_enable(ADC0);
  stk.delay(1);
  /* ADC calibration and reset calibration */
  adc_calibration_enable(ADC0);
  stk.delay(1);
  /* ADC DMA function enable */
  adc_dma_mode_enable(ADC0);
}

void initDAC(void)
{
  dac_deinit();
  dac_trigger_source_config(DAC0, DAC_TRIGGER_SOFTWARE);
  dac_trigger_enable(DAC0);
  dac_wave_mode_config(DAC0, DAC_WAVE_DISABLE);
  dac_output_buffer_enable(DAC0);
  dac_enable(DAC0);

  dac_trigger_source_config(DAC1, DAC_TRIGGER_SOFTWARE);
  dac_trigger_enable(DAC1);
  dac_wave_mode_config(DAC1, DAC_WAVE_DISABLE);
  dac_output_buffer_enable(DAC1);
  dac_enable(DAC1);
}

void initUART()
{
  /* enable USART clock */
  rcu_periph_clock_enable(RCU_USART0);
  /* connect port to USARTx_Tx */
  gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_9);
  /* USART configure */
  usart_deinit(USART0);
  usart_baudrate_set(USART0, 9600U);
  usart_word_length_set(USART0, USART_WL_8BIT);
  usart_stop_bit_set(USART0, USART_STB_1BIT);
  usart_parity_config(USART0, USART_PM_NONE);
  usart_hardware_flow_rts_config(USART0, USART_RTS_DISABLE);
  usart_hardware_flow_cts_config(USART0, USART_CTS_DISABLE);
  usart_transmit_config(USART0, USART_TRANSMIT_ENABLE);
  usart_enable(USART0);
}

float ad2phase(uint16_t in)
{
  float xTmp;
  if (in < 1472) // below -3V
    xTmp = 24.135547645748918;
  else if (in > 3584) // above 8V
    xTmp = 49429.601578493784;
  else
  {
    if (quantized == 0)
      xTmp = freq[in - 1472];
    else
    {
      uint16_t q = (in - 1472 + 8) >> 4; // add 16/2 to quantize between notes
      xTmp = freq[q << 4];
    }
  }
  return (xTmp);
}

void addScope(uint16_t c0, uint16_t c1, uint8_t trig)
{
  if (dispPos < 240)
  {
    if (dispPos > 0 || trig == 1)
    {
      ch0.insert((4095 - c0) / 64);
      ch1.insert((4095 - c1) / 64);
      dispPos++;
    }
  }
}

void dac_out(uint16_t d0, uint16_t d1)
{
  dac_data_set(DAC0, DAC_ALIGN_12B_R, 4095 - d0); // inverted due to inverting op amp
  dac_data_set(DAC1, DAC_ALIGN_12B_R, 4095 - d1); // inverted due to inverting op amp
  dac_software_trigger_enable(DAC0);
  dac_software_trigger_enable(DAC1);
}

int16_t fold(int16_t tmp)
{
  do
  {
    if (tmp < 1088)
      tmp = (1088 * 2 - tmp);
    if (tmp > 3008)
      tmp = (3008 * 2 - tmp);
  } while (tmp < 1088 || tmp > 3008);
  return (tmp);
}

uint16_t deadzone(uint16_t tmp)
{
  if (tmp < 255)        // within?
    return (0);         // ..yes - return zero
  else                  // .. no
    return (tmp - 255); // return value - deadzone
}

float getPhase()
{
  uint8_t p_note;
  uint16_t p_octave;
  p_note = deadzone(ADC.anAvg[2]) >> 4;                             // add deadzone, one octave is 192 AD steps (1V). (4096-1024/16)=192
  p_octave = (ADC.anAvg[4] >> 9) * 192;                             // 4096/512 => 8 octaves
  phaseC = ad2phase(ADC.anAvg[0] + p_octave - (192 << 1) + p_note); // convert CV to logaritmic scale
  return (phaseC);
}

/*  potentiometer and I/O mapping
    R  P2
    P4 P3
    C0 C1
    D0 D1
*/

void OnTimer()
{

#if (pcb_version == 1)
  ADC.anRaw[2] = 4096 - ADC.anRaw[2]; // pot inverted in this pcb version
  ADC.anRaw[3] = 4096 - ADC.anRaw[3]; // pot inverted in this pcb version
#endif

  // static float x;
  static uint8_t songPos;  // position in song
  static uint16_t tCount;  // temp for song
  static uint8_t prevMode; //
  int16_t tmp = 0;
  uint32_t cv2;
  if (moduleMode == mode_quantize)
  {
    quantized ^= 1;
    moduleMode = prevMode;
  }
  if (moduleMode == mode_cvout)
  {
    cvOut ^= 1;
    moduleMode = prevMode;
  }
  
  //-----10|-------20|-------30|-------40|-------50|-------60|-------70|-------80|
  switch (moduleMode)
  {
  case mode_sine_am:                                               // sine (ampitude modulation)
    cv2 = ((ADC.anRaw[1] << 2) * ADC.anAvg[3] >> 11);              // 0-8192. pot2 (bottom right) sets level for CV2 that attenuates or amplifies amplitude
    tmp = 2048 + ((int(vco.sine(getPhase()) - 2048) * cv2) >> 12); // get level from position
    tmp = fold(tmp);                                               // fold if outside range
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);                      // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, vco.phaseTrig);         // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_sine_add:                                      // sine (sum: in1 is added to the oscillator)
    cv2 = ((ADC.anRaw[1] << 2) * ADC.anAvg[3] >> 11);      // 0-8192. pot2 (bottom right) sets level for CV2 that attenuates or amplifies amplitude
    tmp = (int(vco.sine(getPhase()) + cv2) >> 1);          // get level from position
    tmp = fold(tmp);                                       // fold if outside range
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);              // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, vco.phaseTrig); // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_sine_fm:                                       // sine (frequency modulation)
    cv2 = (ADC.anRaw[1] * ADC.anAvg[3] >> 12);             // 12+12-13=11 (0-2048). pot2 (bottom right) sets level for CV2 that modulates the frequency
    tmp = int(vco.sine(getPhase() + cv2 - 1024));          // get level from position (1088-3008 => -5V to +5V)
    tmp = fold(tmp);                                       // fold if outside range
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);              // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, vco.phaseTrig); // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_square_am:                                                      // square (amplitude modulation)
    cv2 = (ADC.anRaw[1] * ADC.anAvg[3] >> 11);                              // 0-8192. pot2 (bottom right) sets level for CV2 that attenuates or amplifies amplitude
    tmp = 2048 + ((int(vco.square(getPhase(), 32768) - 2048) * cv2) >> 12); // get level from position
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);                               // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, vco.phaseTrig);                  // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_square_add:                                    // square (sum: in1 is added to the oscillator)
    cv2 = (ADC.anRaw[1] * ADC.anAvg[3] >> 11);             // 0-8192. pot2 (bottom right) sets level for CV2 that attenuates or amplifies amplitude
    tmp = (int(vco.square(getPhase(), 32768) + cv2) >> 1); // get level from position
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);              // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, vco.phaseTrig); // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_square_fm:                                     // square (frequency modulation)
    cv2 = (ADC.anRaw[1] * ADC.anAvg[3] >> 12);             // 12+12-8=16 (0-65535). pot2 (bottom right) sets level for CV2 that modulates the frequency
    tmp = vco.square(getPhase() + cv2, 32768);             // get level from position (50% dyuty cycle)
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);              // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, vco.phaseTrig); // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_square_pw:                                     // square (pulsewidth modulation)
    cv2 = (ADC.anRaw[1] * ADC.anAvg[3] >> 8);              // 12+12-8=16 (0-65535). pot2 (bottom right) sets level for CV2 that modulates the pulse width
    tmp = vco.square(getPhase(), cv2);                     // get level from position (50% dyuty cycle)
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);              // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, vco.phaseTrig); // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_square_2x:                                     // 2 slightly detuned square oscillators
    cv2 = (ADC.anRaw[1] * ADC.anAvg[3] >> 18);             // 12+12-8=16 (0-65535). pot2 (bottom right) sets level for CV2 that modulates the pulse width
    tmp = vco.square2x(getPhase(), cv2);                   // get level from position (50% dyuty cycle)
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);              // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, vco.phaseTrig); // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_square_3x:                                     // 3 slightly detuned square oscillators
    cv2 = (ADC.anRaw[1] * ADC.anAvg[3] >> 17);             // 12+12-8=16 (0-65535). pot2 (bottom right) sets level for CV2 that modulates the pulse width
    tmp = vco.square3x(getPhase(), cv2);                   // get level from position (50% dyuty cycle)
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);              // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, vco.phaseTrig); // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_triangle_am:                                                      // triangle (amplitude modulation)
    cv2 = ((ADC.anRaw[1] << 2) * ADC.anAvg[3] >> 11);                         // 0-8192. pot2 (bottom right) sets level for CV2 that attenuates or amplifies amplitude
    tmp = 2048 + ((int(vco.triangle(getPhase(), 32768) - 2048) * cv2) >> 12); // get level from position
    tmp = fold(tmp);                                                          // fold if outside range
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);                                 // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, vco.phaseTrig);                    // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_triangle_add:                                    // triangle (sum: in1 is added to the oscillator)
    cv2 = ((ADC.anRaw[1] << 2) * ADC.anAvg[3] >> 11);        // 0-8192. pot2 (bottom right) sets level for CV2 that attenuates or amplifies amplitude
    tmp = (int(vco.triangle(getPhase(), 32768) + cv2) >> 1); // get level from position
    tmp = fold(tmp);                                         // fold if outside range
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);                // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, vco.phaseTrig);   // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_triangle_fm:                                   // triangle (frequency modulation)
    cv2 = (ADC.anRaw[1] * ADC.anAvg[3] >> 8);              // 12+12-8=16 (0-65535). pot2 (bottom right) sets level for CV2 that modulates the frequency
    tmp = vco.triangle(getPhase() + cv2, 32768);           // get level from position (50% dyuty cycle)
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);              // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, vco.phaseTrig); // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_triangle_saw:                                  // triangle (shape modulation)
    cv2 = (ADC.anRaw[1] * ADC.anAvg[3] >> 8);              // 12+12-8=16 (0-65535). pot2 (bottom right) sets level for CV2 that modulates the pulse width
    if (cv2 > 32767)                                       // prevent wrap around
      cv2 = 32767;                                         // ..
    cv2 = cv2 * 2;                                         // double value to get full range without modulation signal (pot only)
    tmp = vco.triangle(getPhase(), cv2);                   // get level from position (50% dyuty cycle)
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);              // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, vco.phaseTrig); // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_triangle_2x:                                   // 2 slightly detuned triangle oscillators
    cv2 = (ADC.anRaw[1] * ADC.anAvg[3] >> 18);             // 0-256. pot2 (bottom right) sets level for CV2 that attenuates or amplifies amplitude
    tmp = vco.triangle2x(getPhase(), cv2);                 // get level from position
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);              // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, vco.phaseTrig); // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_triangle_3x:                                   // 3 slightly detuned triangle oscillators
    cv2 = (ADC.anRaw[1] * ADC.anAvg[3] >> 17);             // 0-256. pot2 (bottom right) sets level for CV2 that attenuates or amplifies amplitude
    tmp = vco.triangle3x(getPhase(), cv2);                 // get level from position
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);              // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, vco.phaseTrig); // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_Noise:                             // white noise generator (PRNG)
    cv2 = (ADC.anRaw[0] * ADC.anAvg[4] >> 13); // pot2 (bottom right) sets level for CV2 that attenuates or amplifies amplitude
    tmp = noise.prng(cv2);                     // get level from position
    dac_out(cvOut ? ADC.anRaw[0] : tmp, tmp);  // output level on DAC1 & DAC0 if ! cvOut (else CV out on DAC0)
    addScope(ADC.anRaw[1], tmp * 2 - 2048, 1); // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_LFO_sine:                                                    // LFO sine
    cv2 = ((ADC.anRaw[1] << 2) * ADC.anAvg[3] >> 11);                    // 0-8192. pot2 (bottom right) sets level for CV2 that attenuates or amplifies amplitude
    tmp = 2048 + ((int(vco.sine(getPhase() / 512) - 2048) * cv2) >> 12); // get level from position
    tmp = fold(tmp);                                                     // fold if outside range
    dac_out(tmp, tmp);                                                   // output level on DAC0 & DAC1
    addScope(ADC.anRaw[1], tmp * 2 - 2048, 1);                           // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_LFO_square:                                    // LFO  square
    tmp = vco.square(getPhase() / 512, ADC.anAvg[3] << 4); // get level from position
    dac_out(tmp, tmp);                                     // output level on DAC0 & DAC1
    addScope(ADC.anRaw[1], tmp * 2 - 2048, 1);             // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_LFO_triangle:                                    // LFO triangle
    tmp = vco.triangle(getPhase() / 512, ADC.anAvg[3] << 4); // get level from position
    dac_out(tmp, tmp);                                       // output level on DAC0 & DAC1
    addScope(ADC.anRaw[1], tmp * 2 - 2048, 1);               // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_4_pole:                                              // VCF (Voltage Controled Filter)
    tmp = vcf.r4pole1(ADC.anRaw[0], ADC.anAvg[4], ADC.anAvg[3]); // sample, cutoff, resonance
    dac_out(tmp, tmp);                                           // output level on DAC0 & DAC1
    addScope(ADC.anRaw[0], tmp, vcf.phaseTrig);                  // store levels in scope buffer
    break;

  case mode_2_pole_v1:                                           // VCF (Voltage Controled Filter)
    tmp = vcf.r2pole1(ADC.anRaw[0], ADC.anAvg[4], ADC.anAvg[3]); // sample, cutoff, resonance
    dac_out(tmp, tmp);                                           // output level on DAC0 & DAC1
    addScope(ADC.anRaw[0], tmp, vcf.phaseTrig);                  // store levels in scope buffer
    break;

  case mode_2_pole_v2:                                           // VCF (Voltage Controled Filter)
    tmp = vcf.r2pole2(ADC.anRaw[0], ADC.anAvg[4], ADC.anAvg[3]); // sample, cutoff, resonance
    dac_out(tmp, tmp);                                           // output level on DAC0 & DAC1
    addScope(ADC.anRaw[0], tmp, vcf.phaseTrig);                  // store levels in scope buffer
    break;

  case mode_test:                                             // VCF (Voltage Controled Filter)
    tmp = vcf.test(ADC.anRaw[0], ADC.anAvg[4], ADC.anAvg[3]); // sample, cutoff, resonance
    dac_out(tmp, tmp);                                        // output level on DAC0 & DAC1
    addScope(ADC.anRaw[0], tmp, vcf.phaseTrig);               // store levels in scope buffer
    break;

  case mode_VCA:                                                // VCA (Voltage Controled Amplifier)
    cv2 = ((ADC.anRaw[0] * ADC.anRaw[1] * ADC.anAvg[3]) >> 21); // pot2 (bottom right) sets level for CV2 that attenuates or amplifies amplitude
    cv2 += (ADC.anAvg[2] >> 1) - 2048;                          // add offset
    dac_out(cv2, cv2);                                          // output level on DAC0 & DAC1
    addScope(ADC.anRaw[0], cv2, 1);                             // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_SnH:                                              // SnH (Sample and Hold)
    tmp = vcf.test(ADC.anRaw[0], ADC.anAvg[4], ADC.anAvg[3]); // sample, cutoff, resonance
    dac_out(tmp, tmp);                                        // output level on DAC0 & DAC1
    addScope(ADC.anRaw[0], tmp * 2 - 2048, 1);                // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_ADSR:                                                                                  // adsr
    tmp = adsr.int_adsr(ADC.anRaw[0], ADC.anAvg[2] << 1, ADC.anAvg[4] << 1, ADC.anAvg[3] << 2, 0); // trig, A,D,R,!S
    cv2 = 2048 + (((tmp - 2048) * (ADC.anRaw[1] - 2048)) >> 9);                                    //
    dac_out(tmp, cv2);                                                                             // output level on DAC0 & DAC1
    break;

  case mode_ADR:                                                                                   // adsr
    tmp = adsr.int_adsr(ADC.anRaw[0], ADC.anAvg[2] << 1, ADC.anAvg[4] << 1, ADC.anAvg[3] << 2, 1); // trig, A,D,R,!S
    cv2 = 2048 + (((tmp - 2048) * (ADC.anRaw[1] - 2048)) >> 9);                                    //
    dac_out(tmp, cv2);                                                                             // output level on DAC0 & DAC1
    break;

  case mode_Delay:                                               // Delay
    tmp = delay.delay(ADC.anRaw[0], ADC.anAvg[4], ADC.anAvg[3]); // sample, mix, length
    dac_out(tmp, tmp);                                           // output level on DAC0 & DAC1
    addScope(ADC.anRaw[0], tmp * 2 - 2048, 1);                   // store levels in scope buffer (amplifies oscillator output 2x)
    break;

  case mode_CV_Play:
    tCount++;
    if (tCount < (4095 - ADC.anAvg[2]) * 5)  // genereate trig signal (50% duty)
      cv2 = 3008;                            // 5V trig signal (> 3.3V threshold)
    else                                     // no trig
      cv2 = 2048;                            // 0V
    if (tCount > (4095 - ADC.anAvg[2]) * 10) // playback speed / tempo
    {
      tCount = 0;
      songPos++;
      if (songPos >= 48)
        songPos = 0;
    }
    tmp = song[songPos];            // add pot + quantization?
    dac_out(tmp, cv2);              // output level on DAC0 & DAC1
    phaseC = 0;                     // DC => 0Hz
    addScope(tmp, cv2, tCount ^ 1); // store levels in scope buffer
    break;

  case mode_out_minus10:            // callibrate -10V
    dac_out(128, 128);              // 3840*(-10+10)/20+128 = 128
    phaseC = 0;                     // DC => 0Hz
    addScope(ADC.anRaw[1], tmp, 1); // store levels in scope buffer
    break;

  case mode_out_0V:                 // callibrate 0V
    dac_out(2048, 2048);            // 3840*(0+10)/20+128 = 2048
    phaseC = 0;                     // DC => 0Hz
    addScope(ADC.anRaw[1], tmp, 1); // store levels in scope buffer
    break;

  case mode_out_3V3:                // callibrate 3V3
    dac_out(2682, 2682);            // 3840*(3.3+10)/20+128 = 2682
    phaseC = 0;                     // DC => 0Hz
    addScope(ADC.anRaw[1], tmp, 1); // store levels in scope buffer
    break;

  case mode_out_10V:                // callibrate 10V
    dac_out(3968, 3968);            // 3840*(10+10)/20+128 = 3968
    phaseC = 0;                     // DC => 0Hz
    addScope(ADC.anRaw[1], tmp, 1); // store levels in scope buffer
    break;

  case mode_in1_to_out1:                                              // calibrate input (connect out to in and match triangle waveform)
    phaseC = 450;                                                     //
    tmp = vco.triangle(phaseC, ADC.anAvg[3] << 4);                    // triangle waveform (get level from position)
    dac_out(tmp, tmp);                                                // output level on DAC0 & DAC1
    addScope(ADC.anRaw[0] * 2 - 2048, tmp * 2 - 2048, vco.phaseTrig); // store levels in scope buffer
    break;

  case mode_in2_to_out1:                                              // calibrate input (connect out to in and match triangle waveform)
    phaseC = 450;                                                     //
    tmp = vco.triangle(phaseC, ADC.anAvg[3] << 4);                    // triangle waveform (get level from position)
    dac_out(tmp, tmp);                                                // output level on DAC0 & DAC1
    addScope(ADC.anRaw[1] * 2 - 2048, tmp * 2 - 2048, vco.phaseTrig); // store levels in scope buffer
    break;

  case mode_pass_thru:                                             // pass thru to meassure noise and crosstalk
    dac_out(ADC.anRaw[0], ADC.anRaw[1]);                           // output ADC0 to DAC0 & ACD1 to DAC1
    addScope(ADC.anRaw[0] * 2 - 2048, ADC.anRaw[1] * 2 - 2048, 1); // store levels in scope buffer
    break;

  case mode_square_A4:                          // used to measure frequency accuracy
    phaseC = 1299;                              // 440Hz - A4 concert pitch (midi 69) Should be 2611.2 @ 108MHz -> 44.4KHz
    tmp = vco.square(phaseC, 32768);            // square waveform (get level from position)
    dac_out(tmp, tmp);                          // output level on DAC0 & DAC1
    addScope(ADC.anRaw[0], tmp, vco.phaseTrig); // store levels in scope buffer
    break;

  case mode_manual_sine:
    tmp = (ADC.anAvg[2] >> 1) + 1472;           // 1472->3520 (not full range:1472->3584)
    phaseC = ad2phase(tmp);                     // convert CV to logaritmic scale
    tmp = vco.sine(phaseC);                     // get level from position
    dac_out(tmp, tmp);                          // output level on DAC0 & DAC1
    addScope(ADC.anAvg[2], tmp, vco.phaseTrig); // store levels in scope buffer
    break;

  case mode_manual_CV:                       // pot 3 controls cv1, pot2 controls cv2
    dac_out(ADC.anAvg[4], ADC.anAvg[3]);     // 4095*(10+10)/20 = 4095
    phaseC = 0;                              // DC => 0Hz
    addScope(ADC.anAvg[4], ADC.anAvg[3], 1); // store levels in scope buffer
    break;
  }
  prevMode = moduleMode;

  // LED.green_off();

  // Running average is done after DAC since it will add jitter due to uneven number of cycles
  ADC.anCount++;
  ADC.update(0); // ADC0
  ADC.update(1); // ADC1
  ADC.update(2); // pot0 (not inverted anymore)
  ADC.update(3); // pot1 (not inverted anymore)
  ADC.update(4); // pot2

  // Start ADC sampling (using DMA)
  adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL); // start ADC: DMA => adc_value[]

  // handle menu from rotation encoder
  
  #if (pcb_version == 0)
  #define cw 'W'
  #define cc 'C'
  #else
  #define cw 'C'
  #define cc 'W'
  #endif

  switch (enc.get())
  {
  case 0:
    LED.red_off();
    LED.blue_off();
    break;
  case cw: // test clockwise (next menu)
    LED.red_on();
    menuPos = menuNxt[menuPos];
    menuUpd = 1;
    break;
  case cc: // test counter clockwise (previous menu)
    LED.blue_on();
    menuPos = menuPre[menuPos];
    menuUpd = 1;
    break;
  case 'S': // test encoder click (menu select)
    if (menuSel[menuPos] < 128)
    {
      menuPos = menuSel[menuPos];
    }
    else
      moduleMode = menuSel[menuPos];
    menuUpd = 1; // for main loop (update display)
    break;
  }
}
//-----10|-------20|-------30|-------40|-------50|-------60|-------70|-------80|
int main()
{
  SPI.begin();
  LED.begin();
  stk.begin(1000);
  rcu_config();
  gpio_config();
  dma_config();
  initADC();
  initDAC();
  // initUART();
  Display.begin(&SPI, font);
  Display.showImg(img_1337, sizeof(img_1337), 0, 50, 240, 86, RGBToWord(0x00, 0xff, 0xff));
  Display.showImg(img_modular, sizeof(img_modular), 0, 150, 240, 32, RGBToWord(0xff, 0x00, 0xff));
  stk.delay(2000);
  Display.fillRectangle(0, 0, 240, 240, RGBToWord(0x0, 0x0, 0x0));
  Display.drawRectangle(0, 70, 239, 79, RGBToWord(0xff, 0xff, 0xff));
  T.begin();
  T.attach(OnTimer);
  uint8_t oldMode = 0;
  while (1)
  {
    if (moduleMode != oldMode) // update display icon
    {
      switch (moduleMode)
      {
      case mode_sine_am:
      case mode_sine_add:
      case mode_sine_fm:
      case mode_square_am:
      case mode_square_add:
      case mode_square_fm:
      case mode_square_pw:
      case mode_triangle_am:
      case mode_triangle_add:
      case mode_triangle_fm:
      case mode_triangle_saw:
      case mode_triangle_2x:
      case mode_triangle_3x:
        Display.showImg(img_vco, sizeof(img_vco), 0, 0, 240, 60, RGBToWord(0x00, 0xff, 0xff));
        break;
      case mode_Noise:
        noise.init(Display);
        break;
      case mode_LFO_sine:
      case mode_LFO_square:
      case mode_LFO_triangle:
        Display.showImg(img_lfo, sizeof(img_lfo), 0, 0, 240, 60, RGBToWord(0x00, 0xff, 0xff));
        break;
      case mode_4_pole:
      case mode_2_pole_v1:
      case mode_2_pole_v2:
      case mode_test:
        Display.showImg(img_vcf, sizeof(img_vcf), 0, 0, 240, 60, RGBToWord(0x00, 0xff, 0xff));
        break;
      case mode_ADSR:
        adsr.init(Display);
        adsr.draw(Display, ADC.anRaw[0], ADC.anAvg[2], ADC.anAvg[4], ADC.anAvg[3], 0);
      case mode_ADR:
        adsr.init(Display);
        adsr.draw(Display, ADC.anRaw[0], ADC.anAvg[2], ADC.anAvg[4], ADC.anAvg[3], 1);
        break;
      case mode_VCA:
        Display.showImg(img_vca, sizeof(img_vca), 0, 0, 240, 60, RGBToWord(0x00, 0xff, 0xff));
        break;
      case mode_SnH:
        Display.showImg(img_snh, sizeof(img_snh), 0, 0, 240, 60, RGBToWord(0x00, 0xff, 0xff));
        break;
      case mode_Delay:
        Display.showImg(img_dly, sizeof(img_dly), 0, 0, 240, 60, RGBToWord(0x00, 0xff, 0xff));
        break;
      case mode_CV_Play:
        Display.showImg(img_play, sizeof(img_play), 0, 0, 240, 60, RGBToWord(0x00, 0xff, 0xff));
        break;
      case mode_out_minus10:
      case mode_out_0V:
      case mode_out_3V3:
      case mode_out_10V:
      case mode_in1_to_out1:
      case mode_in2_to_out1:
      case mode_manual_sine:
      case mode_square_A4:
        Display.showImg(img_cal, sizeof(img_cal), 0, 0, 240, 60, RGBToWord(0xff, 0x00, 0xff));
        break;
      default:
        Display.fillRectangle(0, 0, 240, 60, RGBToWord(0x0, 0x0, 0x0));
        break;
      }
      oldMode = moduleMode;
    }

    switch (moduleMode)
    {
    case mode_ADSR:
      adsr.draw(Display, ADC.anRaw[0], ADC.anAvg[2], ADC.anAvg[4], ADC.anAvg[3], 0); // display, gate, A, D, R, !S
      break;
    case mode_ADR:
      adsr.draw(Display, ADC.anRaw[0], ADC.anAvg[2], ADC.anAvg[4], ADC.anAvg[3], 1); // display, gate, A, D, R, !S
      break;
    }

    if (dispPos >= 240)
    {
      // show scope
      for (uint32_t i = 1; i < SCOPE_BUFFER_SIZE - 1; i++)
      {
        ch0old.draw1(Display, i);     // clear old pixel
        ch0.draw1(Display, i);        // write new pixel
        ch0old.write(i, ch0.read(i)); // save old position
        ch1old.draw1(Display, i);
        ch1.draw1(Display, i);
        ch1old.write(i, ch1.read(i));
      }
      dispPos = 0;

      // show AD values
      char str[11];
      sprintf(str, "%d", ADC.anAvg[0]);
      Display.fillRectangle(130, 160, 40, 16, RGBToWord(0x00, 0x00, 0x00));
      Display.putStr(str, 130 - 9, 160, RGBToWord(0x00, 0x00, 0xff), RGBToWord(0x00, 0x00, 0x00));
      sprintf(str, "%d", ADC.anAvg[1]);
      Display.fillRectangle(190, 160, 40, 16, RGBToWord(0x00, 0x00, 0x00));
      Display.putStr(str, 190 - 9, 160, RGBToWord(0x00, 0x00, 0xff), RGBToWord(0x00, 0x00, 0x00));
      if (!quantized || !cvOut)
        Display.fillRectangle(190, 180, 40, 16, RGBToWord(0x00, 0x00, 0x00));
      if (quantized)
      {
        sprintf(str, "Q");
        Display.putStr(str, 190 - 9, 180, RGBToWord(0xff, 0x00, 0x00), RGBToWord(0x00, 0x00, 0x00));
      }
      if (cvOut)
      {
        sprintf(str, "C");
        Display.putStr(str, 210 - 9, 180, RGBToWord(0xff, 0x00, 0xff), RGBToWord(0x00, 0x00, 0x00));
      }
      // show pot values
      sprintf(str, "%d", ADC.anAvg[2]);
      Display.fillRectangle(130, 180, 40, 16, RGBToWord(0x00, 0x00, 0x00));
      Display.putStr(str, 130 - 9, 180, RGBToWord(0x00, 0xff, 0x00), RGBToWord(0x00, 0x00, 0x00));
      sprintf(str, "%d", ADC.anAvg[3]);
      Display.fillRectangle(130, 200, 40, 16, RGBToWord(0x00, 0x00, 0x00));
      Display.putStr(str, 130 - 9, 200, RGBToWord(0x00, 0xff, 0x00), RGBToWord(0x00, 0x00, 0x00));
      sprintf(str, "%d", ADC.anAvg[4]);
      Display.fillRectangle(130, 220, 40, 16, RGBToWord(0x00, 0x00, 0x00));
      Display.putStr(str, 130 - 9, 220, RGBToWord(0x00, 0xff, 0x00), RGBToWord(0x00, 0x00, 0x00));
      uint16_t freqency = int(phaseC * 44400 / (2 * 65536));
      if (freqency < 1000)
        sprintf(str, "%dHz", freqency);
      else
        sprintf(str, "%d", freqency);
      Display.fillRectangle(190, 200, 50, 16, RGBToWord(0x00, 0x00, 0x00));
      Display.putStr(str, 190 - 9, 200, RGBToWord(0xff, 0xff, 0xff), RGBToWord(0x00, 0x00, 0x00));
      sprintf(str, "%d V", (4095 - ADC.anAvg[2]) * 10 / 2048 - 10);
      Display.fillRectangle(190, 220, 50, 16, RGBToWord(0x00, 0x00, 0x00));
      Display.putStr(str, 190 - 9, 220, RGBToWord(0xff, 0xff, 0xff), RGBToWord(0x00, 0x00, 0x00));
    }

    // show menu
    if (menuUpd != 0)
    {
      char str[11];
      Display.fillRectangle(18, 160, 110, 20, RGBToWord(0x00, 0x00, 0x00));
      if (menuPos != menuPre[menuPos])
        Display.putStr(menuTxt[menuPre[menuPos]], 10, 160, RGBToWord(0xff, 0xff, 0xff), RGBToWord(0x00, 0x00, 0x00));

      sprintf(str, ">");
      Display.putStr(str, 0, 180, RGBToWord(0x00, 0xff, 0xff), RGBToWord(0x00, 0x00, 0x00));

      Display.fillRectangle(18, 180, 110, 20, RGBToWord(0x00, 0x00, 0x00));
      Display.putStr(menuTxt[menuPos], 10, 180, RGBToWord(0x00, 0xff, 0xff), RGBToWord(0x00, 0x00, 0x00));
      if (menuPos != menuNxt[menuPos])
      {
        Display.fillRectangle(18, 200, 110, 40, RGBToWord(0x00, 0x00, 0x00));
        Display.putStr(menuTxt[menuNxt[menuPos]], 10, 200, RGBToWord(0xff, 0xff, 0xff), RGBToWord(0x00, 0x00, 0x00));
        if (menuNxt[menuPos] != menuNxt[menuNxt[menuPos]])
        {
          Display.fillRectangle(18, 220, 110, 20, RGBToWord(0x00, 0x00, 0x00));
          Display.putStr(menuTxt[menuNxt[menuNxt[menuPos]]], 10, 220, RGBToWord(0xff, 0xff, 0xff), RGBToWord(0x00, 0x00, 0x00));
        }
      }
      else
      {
        Display.fillRectangle(18, 200, 110, 40, RGBToWord(0x00, 0x00, 0x00)); // end of menu, clear display
      }
      menuUpd = 0;
    }
  }
}
//-----10|-------20|-------30|-------40|-------50|-------60|-------70|-------80|